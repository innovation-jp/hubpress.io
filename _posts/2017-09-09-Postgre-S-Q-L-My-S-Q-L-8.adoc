# PostgreSQLとMySQL、使うならどっち？ データベース専門家が8つの視点で徹底比較！という記事を読んで勉強したこと
:hp-alt-title:PostgreSQLとMySQL、使うならどっち？ データベース専門家が8つの視点で徹底比較！という記事を読んで勉強したこと
:hp-tags: Shirota, PostgresSQL, MySQL


|===
||PostgreSQL|MySQL|補足

|DDL操作のブロッキング
|発生するが、pg_repackという外部ツールを使えば、REINDEXや一部のALTER文を最小限のロックで実行可。
|バージョン5.6から、多くのDDL操作でトランザクション中でもテーブルへのブロックがかからないようになった。（ノンブロッキング）
|

|SELECT文パフォーマンス
|
|大量データのソート（ORDER BYして、テーブルの全データを取得する）のは遅い。ソートアルゴリズムがそれほど優れていない。新規10件、100件（Top n レコード）を取得するのは速い。
|

|UPDATE文パフォーマンス
|追記型アーキテクチャであり、INSERTに近い処理が行われ、変更前の行に削除フラグのようなものが立てられている。
|文字通り本当に変更前の行を上書きしている
|

|DELETE文パフォーマンス
|
|かつて、DELETE文は遅かった。データ削除後にセカンダリーインデックスを同期処理で貼り直していた。バージョン5.5からは、その処理はサーバがアイドル状態のときなどに行われる非同期処理になり、以前ほどDELETEが遅いということはなくなった。
|

|JOINアルゴリズム
|3種類ともサポート
|ネステッドループ結合のみ
|JOINアルゴリズムには、 +
* ネステッドループ結合（Nested Loop Join） +
* ハッシュ結合（Hash Join） +
* ソートマージ結合（Sort Merge Join） +
の3種類がある。 +
それぞれのユースケースは後述（※）

|トランザクション処理の分離レベル
|デフォルトはREAD-COMMITTEDであるが、 +
REPEATABLE-READにしたときのファントムリードの防ぎ方は、ネクストキーロックはせずに別の方法を用いていて、MySQLより優れていると言えるかもしれない。
|デフォルトがREPEATABLE-READであり、ファントムリードを避けるためネクストキーロックという仕組みを採用している。 +
（※ネクストキーロックとは、主キーのインクリメント先の値までロックをかける仕組み。）
|トランザクション処理の分離レベルは、 +
* SERIALIZABLE +
* REPEATABLE-READ +
* READ-COMMITTED +
* READ-UNCOMMITTED +
の4種類ある。 +
詳細は後述（※） +
 +
 
※ファントムリードとは、並行して動作している他のトランザクションが追加したデータが途中で見えてしまう現象

|ストアドプロシージャ、トリガー
|SQL以外にも、Pythonなどを利用した外部プロシージャが使える
|SQLのみ。MySQL単体ではストアドプロシージャのステップ実行ができない。バージョン5.6以前では1テーブルに付き6つまでしかマルチトリガーが仕掛けられなかった。また、BEFORE INSERT TRIGGERが1テーブルにつき1個しか仕掛けられなかった。それ以降のバージョンではトリガー数の制限はなくなった。トリガーの種類は、FOR EACH ROWしかなくてFOR EACH STATEMENTがない。
|

|レプリケーションの論理型と物理型
|物理型のみ。バージョン10からは論理型も使えるようになる。
|バージョン5.6までは、論理型がデフォルト。バージョン5.7以降では物理型がデフォルト。（※背景としては、論理型は良くも悪くも柔軟で、例えばマスターとスレーブのスキーマが違っていてもSQLさえ通ってしまえばエラーにならない。安全側である物理型をデフォルトにした。）
|論理型は、SQL文そのものをコピー +
物理型は、変更後の行イメージをコピー

|どちらかにしかない便利機能
|ウィンドウ関数、WITH句など集計に適した機能がある。 +
複数のCPUを利用して処理速度を速めるパラレルクエリというものがある。 +
地図や幾何学データを扱うための、PostGISというサードパーティのOSSツールがある。 +
オンラインかつリモートでDBクラスタのベースバックアップが取れる、pg_basebackupが便利。
|ウィンドウ関数、WITH句は、バージョン8.0から導入予定。
|

|データ型の暗黙的に処理される型変換や文字列比較
|型変換は堅い方に寄せている。
|バージョン5.6以前はデータ型のゆるさが問題になることが多かった。バージョン5.7以降は堅い方に修正されていっている。とは言え、暗黙的型変換により、以下の3つの値は同じ値とみなされる +
* (int) 1 +
* (string) '1' +
* (string) '1Q84' +
文字列比較は、デフォルト設定では大文字と小文字の区別はしない。また、バージョン8.0からは、デフォルト設定だと濁音と半濁音を区別しなくなる。「はは」と「ぱぱ」と「ばば」はイコールになる。「びょういん」と「びよういん」もイコールになる。これはUnicodeの仕様に依存しており、厳格さのレベル1〜4が存在し、「は」「ぱ」「ば」を区別するにはレベル2以上が、「びょういん」と「びよういん」を区別するにはレベル3以上が必要だが、処理の高速化を思想としているため切り捨てている。
|

|結論
|多機能であることが利点
|シンプルなWebサービスに向いている
|
|===

ネステッドループ結合
結合されるテーブルのどちらかのデータ量が少なくて、もう一方が多いようなとき
もしくは、
インナーテーブル側がインデックススキャンを使えるとき

ハッシュ結合
結合対象のデータ量が多いときで、データがソートされていないとき

ソートマージ結合
結合対象のデータ量が多いときで、データが既にソートされているとき

