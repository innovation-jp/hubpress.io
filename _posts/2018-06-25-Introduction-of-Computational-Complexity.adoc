# アルゴリズム計算量入門　〜　②
:hp-alt-title: Introduction of Computational Complexity
:hp-tags: Complexity, Sort Algorithm, bigen

どうも、bigenです。 +
なぜ２本連続で書いているかというと、先週のブログ当番をブッチしてしまった罰ゲームです！ +
 +
そんなわけで、前回の記事（:::TODO: ①の記事へのリンク:::）に引き続き、ソートアルゴリズムの計算量について見ていこうと思います。 +
 +
 【前回の記事のまとめ】 +
 バブルソート： 時間計算量 *_O(n^2^)_*, 空間計算量*_O(n)_* +
 バケツソート： 時間計算量 *_O(m + n)_*, 空間計算量*_O(m + n)_* +
 マージソート： 時間計算量 *_O(n_ log _n)_*, 空間計算量*_O(n)_* +
 【まとめおわり】 +
 +
 今回は、実際にphpでそれぞれのアルゴリズムを動かして、「計算量本当にそれであってんの？」っていうのを見ていきたいと思います。 +
 +
 
## 前提条件
OS: macOS High Sierra ver.10.13.5 +
CPU: 第7世代の2.3GHzデュアルコアIntel Core i5プロセッサ +
メモリ: 8GB 2,133MHz LPDDR3メモリ +
PHP version: 7.1.16 +
 +
対象とする問題は、 +

 1~mの範囲のランダムな自然数n個からなる配列を昇順にソートする

としています。 +
アルゴリズムを含め、ソースは初心に帰って自力で用意しました。 +
記事の末尾に付録としておいておきますので、暇な方はご参照ください。 +


## 計算時間について

時間計算量は、それぞれ +
+
 バブルソート： 時間計算量 *_O(n^2^)_* +
 バケツソート： 時間計算量 *_O(m + n)_* +
 マージソート： 時間計算量 *_O(n_ log _n)_*  +
+
でした。 +
 +
まずはデータの範囲は1~100の自然数に固定（*_m=100_*）し、データの数*_n_*を変化させた時に計算時間がどうなるか見ていきましょう。 +
 +

.計算時間(s) , m = 100
[options="header"]
|=======================
|               |n=100        |n=1000      |n=10000    | n=100000
|バブルソート  |0.0002770  |0.0278578 |2.7695038 | 287.1152839
|バケツソート  |0.0000241  |0.0000670 |0.0005970 |0.0061991
|マージソート  |0.0002079  |0.0030000 |0.1332741 |11.2226848
|=======================

*バブルソート*から見てみると、nが10倍になるにつれ、ほぼ100倍ずつきれいに遅くなっていますね。 +
アルゴリズムがシンプルなのもあり、他の依存要素が少ないため綺麗に比例してくれました。 +


*バケツソート* は、n:100 -> 1000は3倍程度しか増えていませんが、n: 1000 ->10000 -> 100000はほぼ10倍ずつ増えています。
これは、nが小さい領域ではデータの範囲mに依存する分が大きかったためでしょう。  +
n=100: 100(mに依存する時間) + 20(nに依存する時間) = 120 +
n=1000: 100(mに依存する時間) + 200(nに依存する時間) = 300 +
n=10000: 100(mに依存する時間) + 2000(nに依存する時間) = 2100 +
みたいな感じで増えていったっていうことですね。