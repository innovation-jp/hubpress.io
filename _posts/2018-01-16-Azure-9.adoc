= 執筆中
:hp-alt-title: Azure 9
:hp-tags: syoga, log, Azure, Go, Cosmos DB

明けましておめでとうございます、SRE チームの syoga です。

来週ついに Monster Hunter World が発売する訳ですが、ネット人見知りの私はソロで頑張る予定です、
そんな中思いついた事を今回のブログに書き綴りたいと思います。

## 思いついた事
以前の記事でログについての思いの丈をぶつけたのですが、個人的にオートスケーリングやコンテナ化、サーバレスが当たり前になってきた世の中では、ログをファイルに出力するというのは、もう一人で一狩り行くようなものではないでしょうか。

という訳で、Go 言語を利用し Azure Cosmos DB（以下 CosmosDB）にログを出力する実験を行ってみました。

## CosmosDB で Go!!
まずは Azure ポータル画面で CosmosDB を作成します、CosmosDB はグローバル分散型のデータベースとなり、なんと 99.999% の高可用性を誇るため、もしもの事を気にせず安心してログを出力できます。

CosmosDB では利用する API を選択できるのですが、今回は MongoDB API を利用したいと思います、リソースの作成部分は割愛しますが、東日本リージョンに CosmosDB を作成しました。

## Go で Go!!
まずは MongoDB API を利用する上で必要なパッケージを取得します。
```
go get gopkg.in/mgo.v2
```
さっそく実装してみます。

```
package main

import (
	"crypto/tls"
	"fmt"
	"net"
	"os"
	"time"

	"github.com/mitchellh/go-ps"
	"gopkg.in/mgo.v2"
)

const (
	DEBUG = "DEBUG"
	INFO  = "INFO"
	WARN  = "WARN"
	ERROR = "ERROR"
	FATAL = "FATAL"
)

// Azure Cosmos DB 接続情報
const (
	Host = "CosmosDB 作成時に払出されたホスト名を設定"
	User = "CosmosDB 作成時に払出されたユーザ名を設定"
	Pass = "CosmosDB 作成時に払出された接続キーを設定"
)

// ログ出力構造体
type Logstruct struct {
	Loglevel     string
	Logdate      string
	Logmessage   string
	Logprocess   string
	Logprocessid int
}

func main() {
	// DialInfo 構造体に接続情報を設定し DialServer 関数を定義し、tls.Dial で CosmosDB に接続
	dialInfo := &mgo.DialInfo{
		Addrs:    []string{fmt.Sprintf("%s.documents.azure.com:10255", Host)},
		Timeout:  60 * time.Second,
		Database: Host,
		Username: User,
		Password: Pass,
		DialServer: func(addr *mgo.ServerAddr) (net.Conn, error) {
			return tls.Dial("tcp", addr.String(), &tls.Config{})
		},
	}

	// セッションスタート
	session, err := mgo.DialWithInfo(dialInfo)

	if err != nil {
		fmt.Printf("Can't connect to mongo, go error %v\n", err)
		// エラーの場合はセッションクローズはしない
		os.Exit(1)
	}

	// main 関数 return 後にセッションクローズ
	defer session.Close()

	// セーフモードを無効にして処理を実施
	session.SetSafe(&mgo.Safe{})

	// Golog コレクションを操作
	collection := session.DB(Host).C("Golog")

　　     // プロセスIDからプロセス名を取得
	pid := os.Getpid()
	pidInfo, _ := ps.FindProcess(pid)

	//CosmosDB へ登録
	err = collection.Insert(&Logstruct{
		Loglevel:     INFO,
		Logdate:     time.Now().String(),
		Logmessage:  "小宇宙は燃えているか",
		Logprocess:   pidInfo.Executable(),
		Logprocessid: pidInfo.Pid(),
	})
}

```
上記の main.go をビルドし実行します。
```
go build main.go
./main.go
```
そして Azure ポータル画面から、データエクスプローラを利用し CosmosDB に登録されたデータを確認します。
```
{
	"_id" : ObjectId("5a5dd830a9e72b34d458570f"),
	"loglevel" : "INFO",
	"logdate" : "2018-01-16 19:47:12.643171666 +0900 JST m=+0.519109358",
	"logmessage" : "小宇宙は燃えているか",
	"logprocess" : "main",
	"logprocessid" : 63904
}
```
とりあえず登録は出来たようです、ログ出力内容としては以下となります。 +
・ログレベル +
・ログ出力日時 +
・ログ出力メッセージ +
・ログ出力プロセス +
・ログ出力プロセス ID

## ざっと説明
見ての通り定数、構造体の宣言です、ログ出力情報は配列でも良いかと思いましたが。
```
const (
	DEBUG = "DEBUG"
	INFO  = "INFO"
	WARN  = "WARN"
	ERROR = "ERROR"
	FATAL = "FATAL"
)

// Azure Cosmos DB 接続情報
const (
	Host = "CosmosDB 作成時に払出されたホスト名を設定"
	User = "CosmosDB 作成時に払出されたユーザ名を設定"
	Pass = "CosmosDB 作成時に払出された接続キーを設定"
)

// ログ出力構造体
type Logstruct struct {
	Loglevel     string
	Logdate      string
	Logmessage   string
	Logprocess   string
	Logprocessid int
}
```
CosmosDB に接続するのためはTLS 接続が必要なため
```
   // DialInfo 構造体に接続情報を設定し DialServer 関数を定義し、tls.Dial で CosmosDB に接続
	dialInfo := &mgo.DialInfo{
		Addrs:    []string{fmt.Sprintf("%s.documents.azure.com:10255", Host)},
		Timeout:  60 * time.Second,
		Database: Host,
		Username: User,
		Password: Pass,
		DialServer: func(addr *mgo.ServerAddr) (net.Conn, error) {
			return tls.Dial("tcp", addr.String(), &tls.Config{})
		},
	}

	// コネクションオープン
	session, err := mgo.DialWithInfo(dialInfo)

	if err != nil {
		fmt.Printf("Can't connect to mongo, go error %v\n", err)
		// エラーの場合はセッションクローズはしない
		os.Exit(1)
	}

	// main 関数 return 後にセッションクローズ
	defer session.Close()
```

#### 感想
Go のお勉強として今回作成してみましたが、実際ログを DB に登録するというのはどうかなと思いましたが、個人的には

余談ですが今回のブログタイトルを「CosmosDB で Go!!」にしようと思っていたのですが、意味不明すぎるので自重しました。

完