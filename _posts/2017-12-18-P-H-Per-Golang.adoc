# PHPerがGolangを試してみた 前編
:published_at: 2017-12-18
:hp-tags: PHP, PHPer, Golang, Go言語, Go

## 概要
私はPHPerなのですが、Golangを試してみました。 +
難しいと思った点など書いていければと思います。

* Hello World
* コンパイル処理
* パッケージ
* 変数
* 定数
* 真偽型
* null値
* 配列型
* スライス型
* マップ型
* 条件分岐
* ループ処理
* 構造体

〜後編へ続く〜

## Hello World

++++
<pre style="font-family: Menlo, Courier">
// vi helloworld.go

// メイン処理のパッケージ名
package main

// fmtをインポートしています
import "fmt"

// メインの処理を記述していきます
func main() {
	// 文字列を標準出力します	
	fmt.Println("HelloWorld") // print("Hello World");
}
</pre>
++++

## コンパイル処理

 // コンパイル
 go build helloworld.go
 // 実行
 ./helloworld

## パッケージ

パッケージはPHPで言うところの名前空間のようなものと捉えました。

++++
<pre style="font-family: Menlo, Courier">
// sample01.go

package pkg01

func aaa() {
	
}
</pre>
++++

++++
<pre style="font-family: Menlo, Courier">
//sample02.go

package pkg01

func bbb() {
	aaa() // 同一packageの先程のaaa関数が呼び出される
}
</pre>
++++

尚、同一パッケージのスクリプトファイルは必ず同じディレクトリ内に格納されていなくてはいけません。

### パッケージをインポート

++++
<pre style="font-family: Menlo, Courier">
// 1つだけインポートする場合
import "pkg01"

// 複数インポートする場合
import (
pkg01
pkg02
pkg03
)
</pre>
++++

また、
小文字で始まるメンバーはprivate、
大文字で始まるメンバーはpublicになります。

++++
<pre style="font-family: Menlo, Courier">
package pkg01

// privateになる
func aaa() {
}

// publicになる
func Bbb() {
}
</pre>
++++

## 変数

++++
<pre style="font-family: Menlo, Courier">
var aaa int = 1 // 型と初期値を指定
var bbb int     // 型のみ指定（※型固有の初期値が設定される）
var ccc = 1     // 型推論
</pre>
++++

ソースのトップレベルで宣言すればグローバルスコープ、 +
関数内で宣言すればローカルスコープになります。

尚、ローカル変数のみ以下のように記述可。

 aaa := 1

## 定数

 const aaa string = "hoge"

## 真偽型

 true と false
 
## null値

 nil がそれに相当するようです。

## 配列型

++++
<pre style="font-family: Menlo, Courier">
// 初期化
var aaa [3]int // $aaa = []; ※PHPでは型指定とか配列長していはできません

// 初期値代入
bbb := [3]string{"hoge","fuga","foo"} // $bbb = ["hoge","fuga","foo"]; ※同じく配列長は変えられません

// 配列長省略
ccc := [...]string{"hoge","fuga","foo","bar"} // $ccc = ["hoge","fuga","foo","bar"]; ※型指定できないところ、配列長がこの場合4で固定になる

// インデックスキー指定
ddd := [...]string{1:"hoge",2:"fuga"} // $ddd = [1 => "hoge", 2 => "fuga"];
</pre>
++++

## スライス型

可変長の配列型みたいなもの。こちらのほうがPHPの配列に近いと思いました。

++++
<pre style="font-family: Menlo, Courier">
var aaa []int
bbb := []string{"hoge","fuga","foo"} // $bbb = ["hoge","fuga","foo"];
</pre>
++++

## マップ型
PHPの連想配列的なものと思いました。

++++
<pre style="font-family: Menlo, Courier">
aaa := map[string]int{"hoge":111, "fuga":222}

aaa["hoge"] = 333 // ※この辺はPHPに似ていると思いました。

fmt.Println(aaa["hoge"], aaa["fuga"]) // 333 222 ここも！
</pre>
++++


## 条件分岐

### if文

++++
<pre style="font-family: Menlo, Courier">
var aaa int = 1

if aaa == 1 {
	
} else if aaa == 2 {
	
} else {

}
</pre>
++++
	
### switch文

++++
<pre style="font-family: Menlo, Courier">
var aaa int = 1

switch aaa {
case 1:
	fallthrough
case 2:

default:

}
</pre>
++++


PHPと違うのはbreakが要らないというところです。 +
標準でbreakされます。 +
breakしたくない時は fallthrough と書くようです。

以下の書き方も有効でした。

++++
<pre style="font-family: Menlo, Courier">
var aaa int = 1

switch {
case aaa == 1:
	fallthrough
case aaa == 2:
	
default:

}

// PHPで言うところの
switch (1) {
case $aaa == 1:
case $aaa == 2:
	break;
default:	
}
</pre>
++++


## ループ文

ループは for しかありません！ +
ですが、ちゃんとPHPで言うところの while foreach 的な書き方も存在しました。

++++
<pre style="font-family: Menlo, Courier">
// for文
for i:=0; i<10; i++ {
	fmt.Println(i)
}

// foreach文のようなもの
aaa := map[string]string{"hoge":"fuga", "foo":"bar"}
for k, v := range aaa {
	fmt.Printf("k=%s, v=%s\n", k, v) // k=hoge, v=fuga\n k=foo, v=bar\n
}

// while文のようなもの
i := 0
for i<10 {
	fmt.Println(i)
	w++
}
</pre>
++++

ループを抜ける break +
ループ処理をスキップする continue

これはPHPと同じでした。

## インターフェース型

++++
<pre style="font-family: Menlo, Courier">
type User interface {
	login()
	logout()
}

type Administrator struct {
	id int
	passwd string
}

func (adm Administrator) login() {
	// ログイン処理
}

func (adm Administrator) logout() {
	// ログアウト処理
}

func (adm Administrator) add() {
	// add処理
}

func main() {
	admin := Administrator{10001, "hoge"}
	var user User = admin
	
	user.login()
	user.logout()
	user.add() // 出来ない
}
</pre>
++++

## 構造体

++++
<pre style="font-family: Menlo, Courier">
type User struct {
	name string
	age int
	token string
}

func main() {
	var user User
	user.name = "Shirota"
	user.age = 39
	user.token = "hoge"
	
}
</pre>
++++

こんなように構造体に値を埋め込んで使えるようです。

また、
以下のように構造体に構造体を指定もできるようです。

++++
<pre style="font-family: Menlo, Courier">
type Administrator struct {
	User
	passwd string
}
</pre>
++++

PHPには無い概念と思います。

また、
GoにはClassが無いんだそうです。 +
なので、packageがclassと同等なのかと思ったのですが、 +
何やらそうではないとわかりました。

++++
<pre style="font-family: Menlo, Courier">
package user

type User struct {
}
</pre>
++++

このようにしてしまうと、以下のようなディレクトリ構成になり、冗長です。

++++
<pre style="font-family: Menlo, Courier">
models/
	user/
		user.go
</pre>
++++

ではclassみたいなことをしたい時どうすればよいのか。 +
そこでGoのメソッドを使うのだと捉えました。

関数とメソッドは別物である。

++++
<pre style="font-family: Menlo, Courier">
package main

import "fmt"

type User struct {
    name string
    age int
    token string
}

// メソッド定義
func (u *User) setToken() string {
    u.token = "fuga"
    return u.token
}

func main() {
    user := &User{"Shirota",39,""}
    user.setToken()
    fmt.Println(user.token) // fuga
}
</pre>
++++

Userという構造体に対して setToken というメソッドがある。 +
この図式がクラスに一番近いと感じました。

また、 +
クラスが無いので継承もありませんが、 +
継承のようなことを行いたければ、 +
先述した構造体の中に構造体を入れるという手法

++++
<pre style="font-family: Menlo, Courier">
type Administrator struct {
	User
	passwd string
}
</pre>
++++

を使えば、 +
AdministratorからUserのsetTokenを使えるようです。

## 次回

* 例外処理（※try catch finallyが無い）
* 並列処理

の辺りと、 +
前編後編通しての所感を書きたいと思います。